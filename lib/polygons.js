// Generated by CoffeeScript 1.4.0
(function() {
  var Line, Point, Polygon;

  Point = (function() {

    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.prototype.distanceTo = function(p) {
      var dx, dy;
      if (p == null) {
        return null;
      }
      dx = p.x - this.x;
      dy = p.y - this.y;
      return Math.sqrt(dx * dx + dy * dy);
    };

    return Point;

  })();

  Polygon = (function() {

    function Polygon(vertices) {
      this.vertices = vertices;
      this.closed = false;
      this.filled = false;
      this.colour = "hsl(0, 60%, 60%)";
    }

    Polygon.prototype.contains = function(point) {
      var a, b, crossings, _i, _len, _ref;
      if (!(this.vertices.length > 0)) {
        return false;
      }
      crossings = 0;
      b = this.vertices[this.vertices.length - 1];
      _ref = this.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        if (((a.y > point.y) !== (b.y > point.y)) && point.x < (b.x - a.x) * (point.y - a.y) / (b.y - a.y) + a.x) {
          crossings++;
        }
        b = a;
      }
      return crossings % 2 === 1;
    };

    Polygon.prototype.draw = function(context) {
      var v, _i, _len, _ref;
      if (this.vertices.length < 1) {
        return;
      }
      context.beginPath();
      context.fillStyle = context.strokeStyle = this.colour;
      _ref = this.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        context.lineTo(v.x, v.y);
      }
      if (this.closed) {
        context.lineTo(this.vertices[0].x, this.vertices[0].y);
      }
      context.stroke();
      context.globalAlpha = 0.5;
      if (this.filled) {
        return context.fill();
      }
    };

    return Polygon;

  })();

  Line = (function() {

    function Line(start, end) {
      this.start = start;
      this.end = end;
    }

    Line.prototype.draw = function(context) {
      context.beginPath();
      context.moveTo(this.start.x, this.start.y);
      context.lineTo(this.end.x, this.end.y);
      return context.stroke();
    };

    return Line;

  })();

  window.onload = function() {
    var append, canvas, context, cursor, extend, intersect, line, polygon, polygons, render;
    canvas = document.getElementsByTagName("canvas")[0];
    context = canvas.getContext("2d");
    context.lineWidth = 2.5;
    polygon = new Polygon([]);
    line = void 0;
    polygons = [];
    cursor = function(e) {
      var d, db, de, p, x, y;
      db = document.body;
      de = document.documentElement;
      x = e.clientX + db.scrollLeft + de.scrollLeft - Math.floor(canvas.offsetLeft);
      y = e.clientY + db.scrollTop + de.scrollTop - Math.floor(canvas.offsetTop) + 1;
      p = new Point(x, y);
      d = p.distanceTo(polygon.vertices[0]);
      if ((d != null) && d < 15) {
        return polygon.vertices[0];
      } else {
        return p;
      }
    };
    append = function(e) {
      var p;
      p = cursor(e);
      if (polygon.vertices.length === 0 || p.distanceTo(polygon.vertices[0]) > 0) {
        polygon.vertices.push(p);
        return;
      }
      polygon.closed = true;
      polygon.colour = "hsl(" + (~~(Math.random() * 360)) + ", 60%, 60%)";
      polygons.push(polygon);
      polygon = new Polygon([]);
      return line = void 0;
    };
    extend = function(e) {
      var end, start;
      if (!(polygon.vertices.length > 0)) {
        return;
      }
      start = polygon.vertices[polygon.vertices.length - 1];
      end = cursor(e);
      return line = new Line(start, end);
    };
    intersect = function(e) {
      var p, point, _i, _len, _results;
      point = cursor(e);
      _results = [];
      for (_i = 0, _len = polygons.length; _i < _len; _i++) {
        p = polygons[_i];
        _results.push(p.filled = p.contains(point));
      }
      return _results;
    };
    canvas.onmouseup = append;
    canvas.onmousemove = function(event) {
      extend(event);
      return intersect(event);
    };
    canvas.focus();
    canvas.onselectstart = function() {
      return false;
    };
    (function() {
      var targetTime, vendor, w, _i, _len, _ref;
      w = window;
      _ref = ['ms', 'moz', 'webkit', 'o'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        vendor = _ref[_i];
        if (w.requestAnimationFrame) {
          break;
        }
        w.requestAnimationFrame = w["" + vendor + "RequestAnimationFrame"];
        w.cancelAnimationFrame = w["" + vendor + "CancelAnimationFrame"] || w["" + vendor + "CancelRequestAnimationFrame"];
      }
      targetTime = 0;
      w.requestAnimationFrame || (w.requestAnimationFrame = function(callback) {
        var currentTime;
        targetTime = Math.max(targetTime + 16, currentTime = +(new Date));
        return w.setTimeout((function() {
          return callback(+(new Date));
        }), targetTime - currentTime);
      });
      return w.cancelAnimationFrame || (w.cancelAnimationFrame = function(id) {
        return clearTimeout(id);
      });
    })();
    return (render = function() {
      var p, _i, _len;
      window.requestAnimationFrame(render);
      context.clearRect(0, 0, canvas.width, canvas.height);
      for (_i = 0, _len = polygons.length; _i < _len; _i++) {
        p = polygons[_i];
        p.draw(context);
      }
      if (polygon != null) {
        polygon.draw(context);
      }
      if (line != null) {
        return line.draw(context);
      }
    })();
  };

}).call(this);
